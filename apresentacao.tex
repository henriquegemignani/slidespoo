\documentclass[brazil]{beamer}
\usepackage{beamerthemesplit}
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{color}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancybox}
\usepackage{ulem}
\usepackage{listings}
\usetheme{JuanLesPins}

\title{Objective-C vs C++}
\author{Thiago de Gouveia Nunes\\ Henrique Gemignani Passos Lima}

\begin{document}

\frame{\titlepage}

%-------------------------------------
\section{0. História!}
%-------------------------------------

\frame{
  \begin{center}
    \Huge Um pouco de história...
  \end{center}
}

\frame{
  Objective-C e C++ são "forks" da linguagem C com a implementação de POO, criadas em 1983.
  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{center}
        \textbf{C++} 
      \end{center}
      Implementação com código mais estático de POO, com foco em desempenho.
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{center}
        \textbf{Objective-C}
      \end{center}
      Muito próxima do smalltalk-80 tanto em sintaxe quanto em dinâmismo.
    \end{column}
  \end{columns}
}

%-------------------------------------
\section{1. Semelhanças}
%-------------------------------------

\frame{
  \begin{center}
    \Huge Semelhanças
  \end{center}
}

\frame{
  \begin{itemize}
    \item Extensões de C: código em C pode ser compilado como Objective-C ou C++
    \item Suporte a programação orientada a objetos.
    \item Declaração e código podem ser misturados.
    \item Separação da declaração dos headers em 2 arquivos.
    \item Atributos \textit{public}, \textit{private}, \textit{protected}.
    \item Referênciação de memória.
  \end{itemize}
}

%-------------------------------------
\section{2. Classes}
%-------------------------------------

%-------------------------------------
\subsection{Sintaxe}
%-------------------------------------

\begin{frame}[fragile]
  point2d.h
  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{center}
        C++
      \end{center}
      \lstset{language=C++,basicstyle=\tiny}
      \begin{lstlisting}
        class Point2D {
          public:
            Point2D();

            float x();
            float y();

            Point2D Add(Point2D& right);

          private:
            float x_;
            float y_;
        };
      \end{lstlisting}
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{center}
        Objective-C
      \end{center}
      \lstset{language=C++,basicstyle=\tiny}
      \begin{lstlisting}
        @interface Point2D {
            float x;
            float y;
        }

        -(float) x;
        -(float) y;
        
        -(Point2D*) add: (Point2D*)right;
        @end
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{center}
        C++ \\
        point2d.cc
      \end{center}
      \lstset{language=C++,basicstyle=\tiny}
      \begin{lstlisting}
        Point2D::Point2D() { ... }

        float Point2D::x() { return x_; }
        float Point2D::y() { return y_; }

        Point2D Point2D::Add(Point2D right) {
            return ...
        }
      \end{lstlisting}
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{center}
        Objective-C \\
        point2d.m
      \end{center}
      \lstset{language=C++,basicstyle=\tiny}
      \begin{lstlisting}
        @implementation Point2D
        -(float) x { return self->x; }
        -(float) y { return self->x; }

        -(Point2D*) add: (Point2D*) right {
            return ...;
        }

        @end
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  A principal diferença entre as Classes do Objective-C para as do C++ é a existência de uma classe
  raiz no Objective-C.
\end{frame}

%-------------------------------------
\subsection{Foward Declaration}
%-------------------------------------

\begin{frame}[fragile]
  No C++ podemos usar uma classe não completamente definida usando uma declaração avançada dela. \\
  \lstset{language=C++,basicstyle=\tiny}
  \begin{lstlisting}
    class Bar; //forward declaration 
    class Foo { 
      Bar* bar; 
      public:
        void userBar(void);
    };
  \end{lstlisting}
  No Objective-C o mesmo efeito é obtido usando a palavra reservada \textit{@class}.
  \lstset{language=C++,basicstyle=\tiny}
  \begin{lstlisting}
    @class Bar; //forward declaration 
    @interface Foo : NSObject { 
      Bar* bar; 
    }
    -(void) userBar;
  \end{lstlisting}
\end{frame}

%-------------------------------------
\subsection{Public, Private, Protected}
%-------------------------------------

\begin{frame}
  Nas duas linguagens os conceitos de \textit{public}, \textit{private} e \textit{proteced} existem. \\
  Em C++, tanto métodos quanto atributos podem receber esses modificadores. O padrão é private. \\
  Em Objective-C só atributos podem ser modificados. O padrão é protected. Os métodos sção publicos.
\end{frame}

\begin{frame}
  Uma maneira de contornar esse problema é implementar os métodos "privados" sem declará-los na interface. \\
  Os métodos ainda poderam ser chamados, mas sua existência está escondida. \\
  Ainda nesse assunto, o Objective-C só implementa heranças publicas.
\end{frame}

%-------------------------------------
\subsection{Static}
%-------------------------------------

\begin{frame}
  Em C++ podemos declarar atributos ou métodos com o modificador \textit{static}. Assim eles passam a ser de classe. \\
  O Objective-C não tem suporte direto a essa ideia, mas é possível atingir o mesmo resultado criando uma variável global 
  na implementação e utilizando seus métodos para modificar essa variável.
\end{frame}

\begin{frame}
  Para criar um método de classe em Objective-C é só acrescentar o símbolo '+' na frente da sua declaração, no lugar do '-'.
\end{frame}

%-------------------------------------
\subsection{Métodos}
%-------------------------------------

\begin{frame}[fragile]
  O código abaixo exemplifica a criação e chamada de um método:
  \lstset{language=C++,basicstyle=\tiny}
  \begin{lstlisting}
    //prototype
    void Array::insertObject(void *anObject, unsigned int atIndex)
    
    //use with a "shelf" instance of the Array class and a "book" object
    shelf.insertObject(book, 2);
  \end{lstlisting}
\end{frame}

\end{document}
