\documentclass[brazil]{beamer}
\usepackage{beamerthemesplit}
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{color}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancybox}
\usepackage{ulem}
\usepackage{listings}
\usetheme{JuanLesPins}

\title{Objective-C vs C++}
\author{Thiago de Gouveia Nunes\\ Henrique Gemignani Passos Lima}

\begin{document}

\frame{\titlepage}

%-------------------------------------
\section{0. História!}
%-------------------------------------

\frame{
  \begin{center}
    \Huge Um pouco de história...
  \end{center}
}

\frame{
  Objective-C e C++ são "forks" da linguagem C com a implementação de POO, criadas em 1983.
  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{center}
        \textbf{C++} 
      \end{center}
      Implementação com código mais estático de POO, com foco em desempenho.
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{center}
        \textbf{Objective-C}
      \end{center}
      Muito próxima do smalltalk-80 tanto em sintaxe quanto em dinâmismo.
    \end{column}
  \end{columns}
}

%-------------------------------------
\section{1. Semelhanças}
%-------------------------------------

\frame{
  \begin{center}
    \Huge Semelhanças
  \end{center}
}

\frame{
  \begin{itemize}
    \item Extensões de C: código em C pode ser compilado como Objective-C ou C++
    \item Suporte a programação orientada a objetos.
    \item Declaração e código podem ser misturados.
    \item Separação da declaração dos headers em 2 arquivos.
    \item Atributos \textit{public}, \textit{private}, \textit{protected}.
    \item Referênciação de memória.
  \end{itemize}
}

%-------------------------------------
\section{2. Classes}
%-------------------------------------

%-------------------------------------
\subsection{Sintaxe}
%-------------------------------------

\begin{frame}[fragile]
  point2d.h
  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{center}
        C++
      \end{center}
      \lstset{language=C++,basicstyle=\tiny}
      \begin{lstlisting}
        class Point2D {
          public:
            // Getters
            float x();
            float y();

            // Metodos
            Point2D Add(Point2D& right);

          private:
            // Atributos.
            float x_;
            float y_;
        };
      \end{lstlisting}
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{center}
        Objective-C
      \end{center}
      \lstset{language=C++,basicstyle=\tiny}
      \begin{lstlisting}
        @interface Point2D {
            // Atributos.
            float x;
            float y;
        }

        // Getters
        -(float) x;
        -(float) y;
        
        // Metodos
        -(Point2D*) add: (Point2D*)right;
        @end
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{center}
        C++ \\
        point2d.cc
      \end{center}
      \lstset{language=C++,basicstyle=\tiny}
      \begin{lstlisting}
        float Point2D::x() { return x_; }
        float Point2D::y() { return y_; }

        Point2D Point2D::Add(Point2D right) {
            return ...
        }
      \end{lstlisting}
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{center}
        Objective-C \\
        point2d.m
      \end{center}
      \lstset{language=C++,basicstyle=\tiny}
      \begin{lstlisting}
        @implementation Point2D
        -(float) x { return self->x; }
        -(float) y { return self->x; }

        -(Point2D*) add: (Point2D*) right {
            return ...;
        }

        @end
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  A principal diferença entre as Classes do Objective-C para as do C++ é a existência de uma classe
  raiz no Objective-C.
\end{frame}

%-------------------------------------
\subsection{Foward Declaration}
%-------------------------------------

\begin{frame}[fragile]
  No C++ podemos usar uma classe não completamente definida usando uma declaração avançada dela. \\
  \lstset{language=C++,basicstyle=\tiny}
  \begin{lstlisting}
    class Bar; //forward declaration 
    class Foo { 
      Bar* bar; 
      public:
        void userBar(void);
    };
  \end{lstlisting}
  No Objective-C o mesmo efeito é obtido usando a palavra reservada \textit{@class}.
  \lstset{language=C++,basicstyle=\tiny}
  \begin{lstlisting}
    @class Bar; //forward declaration 
    @interface Foo : NSObject { 
      Bar* bar; 
    }
    -(void) userBar;
  \end{lstlisting}
\end{frame}

%-------------------------------------
\subsection{Public, Private, Protected}
%-------------------------------------

\begin{frame}
  Nas duas linguagens os conceitos de \textit{public}, \textit{private} e \textit{proteced} existem. \\
  Em C++, tanto métodos quanto atributos podem receber esses modificadores. O padrão é private. \\
  Em Objective-C só atributos podem ser modificados, com padrão sendo protected. Todos métodos são públicos.
\end{frame}

\begin{frame}
  Uma maneira de implementar um métodos como "privados" é não declará-los na interface. \\
  Os métodos ainda poderam ser chamados, mas sua existência está escondida.
\end{frame}

%-------------------------------------
\subsection{Static}
%-------------------------------------

\begin{frame}
  Em C++ podemos declarar atributos ou métodos com o modificador \textit{static}. Assim eles passam a ser de classe. \\
  O Objective-C não tem suporte a atributos de classe, mas é possível atingir o mesmo resultado criando uma variável global 
  na implementação e utilizando seus métodos para modificar essa variável.
\end{frame}

\begin{frame}
  Para criar um método de classe em Objective-C é só acrescentar o símbolo '+' na frente da sua declaração, no lugar do '-'.
\end{frame}

%-------------------------------------
\subsection{Métodos}
%-------------------------------------

\begin{frame}[fragile]
  O código abaixo exemplifica a criação e chamada de um método:
  \lstset{language=C++,basicstyle=\tiny}
  \begin{lstlisting}
    //prototype
    void Array::insertObject(void *anObject, unsigned int atIndex)
    
    //use with a "shelf" instance of the Array class and a "book" object
    shelf.insertObject(book, 2);
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  O Objective-C tem a mesma base de mensagens do Smalltalk, com uma diferença na declaração da mensagem. \\
  \lstset{language=C++,basicstyle=\scriptsize}
  \begin{lstlisting}
    -(void) insertObject:(id)anObject:(unsigned int)index
    
    //use with a "shelf" instance of the Array class 
    //and a "book" object
    [shelf insertObject:book:2];
    =============================================================
    -(void) insertObject:(id)anObject atIndex:(unsigned int)index
    
    //use with a "shelf" instance of the Array class 
    //and a "book" object
    [shelf insertObject:book:2]; //Error !
    [shelf insertObject:book atIndex:2]; //OK
  \end{lstlisting}
\end{frame}

\begin{frame}
  Não é possivel chamar um método que não existe em uma classe no C++, o programa nem é compilado. \\
  Já no Objective-C é totalmente possível, e um objeto que não implementa uma mensagem devolve uma Exception específica.
\end{frame}

\begin{frame}
  Assim como o \textit{this} no C++, utilizado para referênciar o objeto atual, temos o \textit{self} no Objective-C. \\
  O \textit{self} não é uma palavra reservada, mas sim um atributo da classe raiz! \\
  No Objective-C a palavra reservada \textit{super} é utilizada para passar mensagems para a classe pai. \\
  Como no C++ temos herança múzltipla, utilizamos o nome da classe pai para ter o mesmo efeito.
\end{frame}

\begin{frame}
  No C++ a assinatura de um método é composta do seu nome e parâmetros ( alêm da presença do modificador \textit{const} ). \\
  Dado isso o C++ consegue implementar o overload de métodos. \\
  O Objective-C também consegue, mas para tanto os métodos devem ter labels diferentes para seus atributos.
\end{frame}

%-------------------------------------
\subsection{Alocação}
%-------------------------------------

\begin{frame}[fragile]
  \begin{columns}
    \begin{column}{.5\textwidth}
        \begin{center}
            C++
        \end{center}
        Objetos podem ser alocados na pilha como uma variável local, ou dinamicamente com o operador \textit{new}.
    \end{column}
    \begin{column}{.5\textwidth}
        \begin{center}
            Objective-C
        \end{center}
        Todos os objetos são alocados dinamicamente, enviando a mensagem \textit{alloc} para a classe.
    \end{column}
  \end{columns}
\end{frame}

\end{document}
